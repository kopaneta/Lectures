// BackTracking
// Начальное состояние s=s_0
// +3
// s_1=s_0+3
// *2
// s_2=2s_0
// 1. Поиск всех возможных решений
// 2. Поиск первого хорошего решения
// 3. Поиск оптимального решения
// 
// Поиск всех возможных решений Задача о 8 ферзях
// На шахматной доске 8х8 расставить 8 ферзей так, чтобы ни один из них не бил другого

procedure Try1(i:integer);//номер ферзя, который мы хотим поставить или уровень, на котором мы находимся
var k:integer;
begin
	for k:=1 to m do//количество возможных ходов
		begin
			//выбор k-го кандидата
			if {подходит} then {Записываем его ход(куда мы ставим ферзя)}
			begin
				//запись хода
				if i<n//(n-количество ферзей, которое нужно расставить)
				then
				Try1(i+1)
				else
					//печать решения;
				//стирание хода
			end;
		end;
end;

// a-массив,который показывает,какие горизонтали заняты
// a_i=true если свободно, false если занято(индексы от 1..8)
// b_ij(контролирует диагональ <-v), причем разность i-j всегда одинакова
// индексы массива от -7..7
// c_ij(контролирует диагональ ->v), причем сумма всегда одинаовая

// Решение задачи с ферзями
const n=8;

type 
	TIndex=1..n;
	TMas=array [TIndex] of TIndex;

var
	x:TMas;//Само решение, которое мы строим
	a:array[1..n] of boolean;
	b:array[(-n-1)..(n-1)] of boolean;
	c:array[2..(n+n)] of boolean;
	i:integer;

procedure Print
var k:integer;
begin
	for k:=1 to n do//количество возможных ходов
		write(x[k],' ');
		writeln;
end;

//работаем с i-ой горизонталью
procedure Try(i:integer);//номер ферзя, который мы хотим поставить или уровень, на котором мы находимся
var k:integer;
begin
	for k:=1 to n do
		if (a[k]) and (b[i-k]) and (c[i+k])
		then //если свободна k-ая горизонталь
			begin
				x[i]:=k;//
				//показываем что горизонталь и две диагонали заняты
				a[k]:=false;
				b[i-k]:=false;
				c[i+k]:=false;

				if i<n then Try(i+1)//расставляем остальных ферзей
				else
				// нашли всех ферзей, печатаем решение
				Print;

				c[i+k]:=true;
				b[i-k]:=true;
				a[k]:=true;
			end;
end;

{main}
begin
	for i:=1 to n do a[i]:=true;
	for i:=(-n-1) to (n-1) do b[i]:=true;
	for i:=2 to (2*n) do c[i]:=true;
	Try(1);
end;

// дан массив из n чисел, напечатать все возможные перестановки
const
	n=6;

type
	TMas=array[1..n] of integer;

procedure PrintMas(a:TMas);

procedure Swap(var a,b:integer);//обмен двух переменных местами

procedure P(var A:TMas; i:integer)//позиция с котрой генерируем перестановку и сам массив
var
	

begin
	if (i=n) then  //если дошли до конца массива
		PrintMas(A)
	else
		for j:=1 to n do
		begin
			Swap(a[i],a[j]);
			P(a,i+1);
			Swap(a[i],a[j]);
		end;
end;

// Может быть ситуация что в а одинакрвые числа
// Написать процедуру генерации перестановок без повторения
// Решение без симметричных вариантов