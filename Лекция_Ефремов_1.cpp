Эффективность алгоритмов
int find_max(std::vector<int> &v;)
{
	if (v.size()==0) return 0;
	int mx=v[0];
	for (int i=1; i<v.size(),i++)
		mx=max(mx,v[i]);
	return mx;
}

1
2
N*(1+1+1+1+1)=5*N
1
В итоге 5*N+4
сравнение - оче много

O - позволяет получить ассимптотическую оценку
f(n)=O(g(n)), если существует c 
f(n)<=cg(n), n>=n_0
O(N*log_2 N)
Полиноминальные алгоритмы
O(N^2)

Астрономия
Взаимодействия небесных тел
Вычисление положений
n=10000
  1000 шагов
 Решение занимало 400 дней
 Одна операция требовала O(n^2)

 1. Оптимизация алгоритма x12
 2. Оптимизация модели x2 
 3. Оптимизация структур данных x2
 4. Оптимизация кода x2
 5. Ассемблер x2,5
 6. Аппаратная оптимизация x2 

 Имеется последовательность целых чисел
 31 -41 59 26 -53 58 97 -93 -23
 Подпоследовательность подряд идущих элементов с ... суммой

long BruteForce (int *x, int n)
{
	long maxofar=0;
	for (int i=0, i<n, i++)
	{
		for (int j=i, j<n, j++)
		{
			long sum=0;
			for (int k=i, k<j, k++)
				sum+=x[k];
			maxofar=max(maxofar,sum);
		}
	}
}

O(n^3)
Это кубический алгоритм ^
10^3=10000
на порядок - в 10 раз
		1 				2
10^3 	1.3c(0.093c)	10мс(0мс)
10^4 	22 мин(81c)		1с(47мс)
10^5 	15 дней			1,7мин(3.2 с)
10^6	41 год			2.8ч
10&7 	41000 лет 		1.7 нед

p2 - 400 mHz

sum[i,j]=sum[i,j-1]+x[j]
long Quadratic(int *x, int n)
{
	long maxofar=0;
	for (int i=0; i<n, i++)
	{
		long sum=0;
		for (int j=i; j<n; j++)
		{
			sum+=x[j];
			maxofar=max(maxofar,sum);
		}
	}
	return maxofar;
}

long DivideAndConquer(int *x, int l, int r)
{
	if l>z return 0;
	if 
}

//продолжение лекции

//новая лекция

Перебор и методы его сокращения
-Перебор с возвратом
U1 ... U_N

Пусть задано N Упорядоченных множеств

A=(a_1,...,a_N) где a_i принадлежит U_i

A=(a_1,...,a_k-1,...??) 
Требуется найти a_k , a_k<=U_k S_k множество элементов которое можно выбрать на данном шаге

если S_k!=0 то выбираем первый элемент из S_N
если S_k==0 то происходит возврат

a_k-1 из S_k-1
Если в процессе перебора с возвратом нашли //нихуя не понял

backtrack(<vector,i>)
{
	if (vector есть решение)
		print vector
	else
	{
		вычислить S_i;
		for <a_i принадлежит S_i>
			backtrack(<vector||a_i,i+1>);
	}
}

|U_i|<=C

Поставить на шахматную доску 8 ферзей, так чтобы они не атаковали друг друга
С_64 ^8

std::vector<bool> vert;

если vert[i]==true, i-я возвр
///
std::vector<bool> vert,up,down;
bool can_move_queen(const std::vector<int> & board)
